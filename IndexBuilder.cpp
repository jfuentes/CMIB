/**
***
*** Copyright  (C) 1985-2011 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation. and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
*** ----------------------------------------------------------------------------
**/

#include <cm/cm.h>
#include "cm_rt.h"

#include "../../compiler/include/cm/cm_vm.h"

#include <time.h>
#include <vector>
#include <bitset>
#include <algorithm>
#include <iostream>
#include <random>
#include <math.h>
#include "K2tree.h"
#include "radixsort.h"

// Includes bitmap_helpers.h for bitmap file open/save/compare operations.
#include "bitmap_helpers.h"

// Include cm_rt_helpers.h to convert the integer return code returned from
// the CM runtime to a meaningful string message.
#include "cm_rt_helpers.h"

// Includes isa_helpers.h to load the ISA file generated by the CM compiler.
#include "isa_helpers.h"

using namespace std;

#ifdef CMRT_EMU
extern "C" void cmk_bits_test();

extern "C" void cmk_last_levels_construction(SurfaceIndex matrix_in, SurfaceIndex L_out, SurfaceIndex T_out, uint total_threads, uint x, uint y);
extern "C" void cmk_mid_levels_construction(SurfaceIndex matrix_in, SurfaceIndex T_out, uint total_threads, uint x, uint y);

extern "C" void cmk_construction_from_edges(SurfaceIndex input, uint offset_start, uint start, uint end);

extern "C" void cmk_generate_morton_numbers(SurfaceIndex input, SurfaceIndex ouput);

extern "C" void PerThreadHist(uint numKeys, uint radixPos, svmptr_t ibuf, svmptr_t obuf);
extern "C" void ScanHist(svmptr_t ibuf, svmptr_t obuf);
extern "C" void ScanKeys(uint numKeys, uint radixPos, svmptr_t ibuf, svmptr_t ibufHist, svmptr_t obuf);
extern "C" void ScanKeysUncoalesced(uint numKeys, uint radixPos, svmptr_t ibuf, svmptr_t ibufHist, svmptr_t obuf);

extern "C" void cmk_neighbors_test(SurfaceIndex T, SurfaceIndex L, SurfaceIndex T_rank, uint t_size, uint l_size, uint height, uint k, uint start, uint end);
extern "C" void cmk_range_test(SurfaceIndex T, SurfaceIndex L, SurfaceIndex T_rank, uint t_size, uint l_size, uint height, uint k, uint start, uint end);
#endif

void cmk_bits_test();
void cmk_last_levels_construction(SurfaceIndex matrix_in, SurfaceIndex L_out, SurfaceIndex T_out, UINT total_threads, UINT x, UINT y);
void cmk_mid_levels_construction(SurfaceIndex matrix_in, SurfaceIndex T_out, UINT total_threads, UINT x, UINT y);
void cmk_generate_morton_numbers(SurfaceIndex input, SurfaceIndex output);

void bitsTest() {
  // Creates a CmDevice from scratch.
  // Param device: pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *device = nullptr;
  unsigned int version = 0;
  cm_result_check(::CreateCmDevice(device, version));
  // The file linear_walker_genx.isa is generated when the kernels in the file
  // linear_walker_genx.cpp are compiled by the CM compiler.
  // Reads in the virtual ISA from "K2tree_genx.isa" to the code
  // buffer.
  std::string isa_code = cm::util::isa::loadFile("IndexBuilder_genx.isa");
  if (isa_code.size() == 0) {
    std::cout << "Error: empty ISA binary.\n";
    exit(1);
  }

  // Creates a CmProgram object consisting of the kernels loaded from the code
  // buffer.
  // Param isa_code.data(): Pointer to the code buffer containing the virtual
  // ISA.
  // Param isa_code.size(): Size in bytes of the code buffer containing the
  // virtual ISA.
  CmProgram *program = nullptr;
  cm_result_check(device->LoadProgram(const_cast<char*>(isa_code.data()),
    isa_code.size(),
    program));

  CmKernel *bits_test_kernel = nullptr;
  cm_result_check(device->CreateKernel(program,
    CM_KERNEL_FUNCTION(cmk_bits_test),
    bits_test_kernel));

  // determine how many threads we need
  // each thread handling 256 elements
  unsigned int width, height; // thread space width and height
  unsigned int total_threads = 1;
  if (total_threads < MAX_TS_WIDTH) {
    width = total_threads;
    height = 1;
  }
  else {
    width = MAX_TS_WIDTH;
    height = total_threads / MAX_TS_WIDTH;
  }
  // Creates a CmThreadSpace object.
  // There are two usage models for the thread space. One is to define the
  // dependency between threads to run in the GPU. The other is to define a
  // thread space where each thread can get a pair of coordinates during
  // kernel execution. For this example, we use the latter usage model.
  CmThreadSpace *thread_space = nullptr;
  cm_result_check(device->CreateThreadSpace(width, height, thread_space));

  // Creates a task queue.
  // The CmQueue is an in-order queue. Tasks get executed according to the
  // order they are enqueued. The next task does not start execution until the
  // current task finishes.
  device->InitPrintBuffer();
  CmQueue *cmd_queue = nullptr;
  cm_result_check(device->CreateQueue(cmd_queue));

  // only call GPU prefix kernel when we have enough work to offload
  cm_result_check(bits_test_kernel->SetThreadCount(total_threads));


  // Creates a CmTask object.
  // The CmTask object is a container for CmKernel pointers. It is used to
  // enqueue the kernels for execution.
  CmTask *bits_test_task = nullptr;
  cm_result_check(device->CreateTask(bits_test_task));

  // Adds a CmKernel pointer to CmTask.
  // This task has one kernel, "cmk_radix_count".
  cm_result_check(bits_test_task->AddKernel(bits_test_kernel));
  //cm_result_check(prefix_task->AddKernel(prefix_kernel));


  std::cout << "Bits test Start..." << endl;

  clock_t start = clock(); // start timer


                           // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
                           // function returns immediately without waiting for the GPU to start or
                           // finish execution of the task. The runtime will query the HW status. If
                           // the hardware is not busy, the runtime will submit the task to the
                           // driver/HW; otherwise, the runtime will submit the task to the driver/HW
                           // at another time.
                           // An event, "sync_event", is created to track the status of the task.
  CmEvent *event = nullptr;
  unsigned long time_out = -1;


  // For small input size, we only have a small number of threads
  // we don't call kernel to compute prefix sum. intead of, CPU simply performs the job
  cm_result_check(cmd_queue->Enqueue(bits_test_task, event, thread_space));
  cm_result_check(event->WaitForTaskFinished(time_out));

  clock_t end = clock(); // end timer
  std::cout << " GPU Prefix Time = " << end - start << " msec " << endl;
  std::cout << "== GPU output begins ==" << endl << endl;
  device->FlushPrintBuffer();
  std::cout << endl << "==  GPU output ends  ==" << endl;
  // Destroy a CmThreadSpace object.
  // CmThreadSpace will be destroyed when CmDevice is destroyed.
  // Here, the application destroys the CmThreadSpace object by itself.
  cm_result_check(device->DestroyThreadSpace(thread_space));
  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
  // were created using this device instance that have not explicitly been
  // destroyed by calling the respective destroy functions.
  cm_result_check(::DestroyCmDevice(device));
}

constexpr static uint64_t  all_set{ -1ULL };

void write_int(uint64_t* word, uint64_t x, uint8_t offset, const uint32_t len)
{
  x &= lo_set[len];
  if (offset + len < 64) {
    *word &=
      ((all_set << (offset + len)) | lo_set[offset]); // mask 1..10..01..1
    *word |= (x << offset);
    //		*word ^= ((*word ^ x) & (bits::lo_set[len] << offset) );
    //      surprisingly the above line is slower than the lines above
  }
  else {
    *word &=
      ((lo_set[offset]));  // mask 0....01..1
    *word |= (x << offset);
    if ((offset = (offset + len) & 0x3F)) { // offset+len > 64
      *(word + 1) &= (~lo_set[offset]); // mask 1...10..0
                                              //			*(word+1) &= bits::lo_unset[offset]; // mask 1...10..0
                                              //          surprisingly the above line is slower than the line above
      *(word + 1) |= (x >> (len - offset));
    }
  }
}

bool loadMatrix(uint32_t * k2treeMatrix, string filename) {
  ifstream file(filename);
  if (!file.good())
    return false;
  int value, i = 0;
  // Read an integer at a time from the line
  while (file >> value)
  {
    // Add the integers from a line to a 1D array (vector)
    k2treeMatrix[i++] = value;
  }
  file.close();
  return true;
}

bool loadFromFile(std::vector<uint32_t> &data, string filename) {
  ifstream file(filename);
  if (!file.good())
    return false;
  uint32_t value, i = 0;
  // Read an integer at a time from the line
  while (file >> value)
  {
    // Add the integers from a line to a 1D array (vector)
    data.push_back(value);
  }
  file.close();
  return true;
}

void K2treeConstructionTest(unsigned int size, string filename) {

  int iterations = 0, tempSize = size / K_ENTRIES;

  while (tempSize >= K_ENTRIES * 4) { // minimum matriz size to dispatch kernels
    iterations++;
    tempSize /= K_ENTRIES;
  }
  std::cout << "Will dispatch Kernel " << iterations << " times for " << filename << "\n";

  uint32_t *k2treeMatrix;
  k2treeMatrix = (uint32_t*)CM_ALIGNED_MALLOC((size) * sizeof(uint32_t), 0x1000);
  if (!loadMatrix(k2treeMatrix, filename)) {
    std::cout << "File " << filename << " with matrix couldn't be read.\n";
    exit(1);
  }

  // Allocate space for final K2tree structures L and T
  uint64_t *L;
  L = (uint64_t*)CM_ALIGNED_MALLOC((size / 64) * sizeof(uint64_t), 0x1000);
  memset(L, 0, sizeof(uint64_t) * (size / 64));
  uint64_t *T;
  T = (uint64_t*)CM_ALIGNED_MALLOC((size / 64) * sizeof(uint64_t), 0x1000);
  memset(T, 0, sizeof(uint64_t) * (size / 64));
  // determine how many threads we need for each iteration
  unsigned int width, height; // thread space width and height
  unsigned int total_threads = size / K_ENTRIES;
  width = total_threads / 2;
  height = total_threads / 2;

  // Every kernel i will write its results into Louts[i] and L
  uint32_t Lsize;
  Lsize = (K_ENTRIES / WORD_SZ + 2) * total_threads; // (L + extabits) * total_threads
  uint32_t *Lout;
  Lout = (uint32_t *)CM_ALIGNED_MALLOC(Lsize * sizeof(uint32_t), 0x1000);
  uint32_t *Tsizes;
  Tsizes = (uint32_t *)CM_ALIGNED_MALLOC(iterations + 1 * sizeof(uint32_t), 0x1000);
  uint32_t **Touts;
  Touts = (uint32_t **)CM_ALIGNED_MALLOC(iterations + 1 * sizeof(uint32_t*), 0x1000);

  for (int i = 0, numThreads = total_threads; i <= iterations; i++, numThreads /= K_ENTRIES) {
    Tsizes[i] = (ceil((K_ENTRIES / pow(K2_VALUE, 2)) / WORD_SZ) + ceil((K_ENTRIES / pow(K2_VALUE, 3)) / WORD_SZ) + 6) * numThreads; // 3 extra words for counting bits
    Touts[i] = (uint32_t *)CM_ALIGNED_MALLOC(Tsizes[i] * sizeof(uint32_t), 0x1000);
  }

  for (int i = 0; i <= iterations; i++)
    std::cout << "iteration " << i << ": " << size << " " << Lsize << " " << Tsizes[i] << " " << total_threads / pow(64, i) << endl;
  // Creates a CmDevice from scratch.
  // Param device: pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *device = nullptr;
  unsigned int version = 0;
  cm_result_check(::CreateCmDevice(device, version));
  // The file linear_walker_genx.isa is generated when the kernels in the file
  // linear_walker_genx.cpp are compiled by the CM compiler.
  // Reads in the virtual ISA from "K2tree_genx.isa" to the code
  // buffer.
  std::string isa_code = cm::util::isa::loadFile("IndexBuilder_genx.isa");
  if (isa_code.size() == 0) {
    std::cout << "Error: empty ISA binary.\n";
    exit(1);
  }

  // Creates a CmProgram object consisting of the kernels loaded from the code
  // buffer.
  // Param isa_code.data(): Pointer to the code buffer containing the virtual
  // ISA.
  // Param isa_code.size(): Size in bytes of the code buffer containing the
  // virtual ISA.
  CmProgram *program = nullptr;
  cm_result_check(device->LoadProgram(const_cast<char*>(isa_code.data()),
    isa_code.size(),
    program));

  // Last_levels kernel will generate L and last 3 levels of T
  CmKernel *last_levels_kernel = nullptr;
  cm_result_check(device->CreateKernel(program,
    CM_KERNEL_FUNCTION(cmk_last_levels_construction),
    last_levels_kernel));
  CmKernel **mid_levels_kernel = nullptr;
  // Mid_levels kernel will generate 4 levels of T
  mid_levels_kernel = (CmKernel **)CM_ALIGNED_MALLOC(iterations * sizeof(CmKernel *), 0x1000);
  for (int i = 0; i < iterations; i++) {
    cm_result_check(device->CreateKernel(program,
      CM_KERNEL_FUNCTION(cmk_mid_levels_construction),
      mid_levels_kernel[i]));
  }


  std::cout << "# threads Kernel 1: " << total_threads << endl;

  // create buffers for input matrix, T and L
  CmBufferUP *matrixBuf;
  cm_result_check(device->CreateBufferUP(size * sizeof(unsigned int), (void*)k2treeMatrix, matrixBuf));
  //cm_result_check(inBuf->WriteSurface((const unsigned char*)k2treeMatrix, NULL));

  CmBuffer *LBuf;
  cm_result_check(device->CreateBuffer(Lsize * sizeof(unsigned int), LBuf));
  CmBuffer **TBuf;
  TBuf = (CmBuffer **)CM_ALIGNED_MALLOC(iterations + 1 * sizeof(CmBuffer *), 0x1000);

  for (int i = 0; i <= iterations; i++) {
    cm_result_check(device->CreateBuffer(Tsizes[i] * sizeof(unsigned int), TBuf[i]));
  }
  // When a surface is created by the CmDevice a SurfaceIndex object is
  // created. This object contains a unique index value that is mapped to the
  // surface.
  // Gets the input surface index.
  SurfaceIndex *input_idx = nullptr;
  cm_result_check(matrixBuf->GetIndex(input_idx));
  SurfaceIndex *L_idx = nullptr;
  cm_result_check(LBuf->GetIndex(L_idx));
  SurfaceIndex **T_idx = nullptr;
  T_idx = (SurfaceIndex **)CM_ALIGNED_MALLOC(iterations + 1 * sizeof(SurfaceIndex *), 0x1000);
  for (int i = 0; i <= iterations; i++) {
    cm_result_check(TBuf[i]->GetIndex(T_idx[i]));
  }
  //SurfaceIndex *output_idx = nullptr;
  //cm_result_check(outBuf->GetIndex(output_idx));

  // Creates a CmThreadSpace object.
  // There are two usage models for the thread space. One is to define the
  // dependency between threads to run in the GPU. The other is to define a
  // thread space where each thread can get a pair of coordinates during
  // kernel execution. For this example, we use the latter usage model.
  //CmThreadSpace *thread_space = nullptr;
  //cm_result_check(device->CreateThreadSpace(width, height, thread_space));

  // Creates a task queue.
  // The CmQueue is an in-order queue. Tasks get executed according to the
  // order they are enqueued. The next task does not start execution until the
  // current task finishes.
  device->InitPrintBuffer();
  CmQueue *cmd_queue = nullptr;
  cm_result_check(device->CreateQueue(cmd_queue));


  cm_result_check(last_levels_kernel->SetThreadCount(total_threads));
  cm_result_check(last_levels_kernel->SetKernelArg(0, sizeof(SurfaceIndex), input_idx));
  cm_result_check(last_levels_kernel->SetKernelArg(1, sizeof(SurfaceIndex), L_idx));
  cm_result_check(last_levels_kernel->SetKernelArg(2, sizeof(SurfaceIndex), T_idx[0]));
  int tt = sqrt(total_threads);
  cm_result_check(last_levels_kernel->SetKernelArg(3, sizeof(tt), &tt));
  int tid = 0;
  for (int x = 0; x < sqrt(total_threads); x++) { // set threads' (x,y)
    for (int y = 0; y < sqrt(total_threads); y++) {
      cm_result_check(last_levels_kernel->SetThreadArg(tid, 4, sizeof(x), &x));
      cm_result_check(last_levels_kernel->SetThreadArg(tid, 5, sizeof(y), &y));
      tid++;
    }
  }

  int numThreads = total_threads / K_ENTRIES;
  for (int i = 1; i <= iterations; i++) { // only call GPU mid_levels kernel when we have enough work to offload
    cm_result_check(mid_levels_kernel[i - 1]->SetThreadCount(numThreads));
    cm_result_check(mid_levels_kernel[i - 1]->SetKernelArg(0, sizeof(SurfaceIndex), input_idx));
    cm_result_check(mid_levels_kernel[i - 1]->SetKernelArg(1, sizeof(SurfaceIndex), T_idx[i]));
    int nt = sqrt(numThreads);
    cm_result_check(mid_levels_kernel[i - 1]->SetKernelArg(2, sizeof(nt), &nt));

    tid = 0;
    for (int x = 0; x < sqrt(numThreads); x++) { // set threads' (x,y)
      for (int y = 0; y < sqrt(numThreads); y++) {
        cm_result_check(mid_levels_kernel[i - 1]->SetThreadArg(tid, 3, sizeof(x), &x));
        cm_result_check(mid_levels_kernel[i - 1]->SetThreadArg(tid, 4, sizeof(y), &y));
        tid++;
      }
    }
    numThreads /= K_ENTRIES;
  }

  // Creates a CmTask object.
  // The CmTask object is a container for CmKernel pointers. It is used to
  // enqueue the kernels for execution.
  CmTask *last_levels_task = nullptr;
  cm_result_check(device->CreateTask(last_levels_task));
  CmTask **mid_levels_tasks = nullptr;
  mid_levels_tasks = (CmTask **)CM_ALIGNED_MALLOC(iterations * sizeof(CmTask *), 0x1000);
  for (int i = 0; i < iterations; i++)
    cm_result_check(device->CreateTask(mid_levels_tasks[i]));

  // Adds a CmKernel pointer to CmTask.
  cm_result_check(last_levels_task->AddKernel(last_levels_kernel));
  for (int i = 0; i < iterations; i++)
    cm_result_check(mid_levels_tasks[i]->AddKernel(mid_levels_kernel[i]));

  std::cout << "K2tree Construction test Start..." << endl;

  clock_t start = clock(); // start timer


                           // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
                           // function returns immediately without waiting for the GPU to start or
                           // finish execution of the task. The runtime will query the HW status. If
                           // the hardware is not busy, the runtime will submit the task to the
                           // driver/HW; otherwise, the runtime will submit the task to the driver/HW
                           // at another time.
                           // An event, "sync_event", is created to track the status of the task.
  CmEvent *event = nullptr;
  unsigned long time_out = -1;

  // For small input size, we only have a small number of threads
  // we don't call kernel to compute prefix sum. intead of, CPU simply performs the job
  cm_result_check(cmd_queue->Enqueue(last_levels_task, event));
  cm_result_check(event->WaitForTaskFinished(time_out));

  cm_result_check(LBuf->ReadSurface((unsigned char *)Lout, event));
  /*
  cout << "L = ";
  for (int i = 0; i < Lsize; i++) {
    cout << Lout[i] << " ";
  }
  cout << endl;
  */
  int bit_idx = 0;
  uint8_t offset = 0;
  for (int i = 0; i < Lsize; i += 4) {
    if (Lout[i] > 0) {
      offset = bit_idx % 64;
      uint64_t x = Lout[i + 1];
      x |= ((uint64_t)Lout[i + 2]) << 32;
      write_int(&L[bit_idx / 64], x, offset, Lout[i]);
      bit_idx += Lout[i];
    }
  }

  cm_result_check(TBuf[0]->ReadSurface((unsigned char *)Touts[0], event));

  for (int i = 1; i <= iterations; i++) { // 256 elems is the minimum to dispatch 2nd kernel
    CmEvent *event2 = nullptr;
    cm_result_check(cmd_queue->Enqueue(mid_levels_tasks[i - 1], event2));
    cm_result_check(event2->WaitForTaskFinished(time_out));
    cm_result_check(TBuf[i]->ReadSurface((unsigned char *)Touts[i], event2));
  }

  // Build compact T
  write_int(&T[bit_idx / 64], (k2treeMatrix[0] | k2treeMatrix[1] << 1 | k2treeMatrix[2] << 2 | k2treeMatrix[3] << 3), 0, 4);
  bit_idx = 4;
  offset = 0;
  for (int i = iterations; i >= 0; i--) {
    for (int j = 0; j < Tsizes[i]; j += 4) {
      if (Touts[i][j] > 0) {
        offset = bit_idx % 64;
        uint64_t x = Touts[i][j + 1];
        write_int(&T[bit_idx / 64], x, offset, Touts[i][j]);
        bit_idx += Touts[i][j];
      }
    }
  }

  clock_t end = clock(); // end timer

  cout << "compact L = ";
  for (int i = 0; i < size / 64 && L[i] != 0; i++) {
    cout << L[i] << " ";
  }
  cout << endl;

  cout << "final compact T = ";
  for (int i = 0; i < size / 64 && T[i] != 0; i++) {
    cout << T[i] << " ";
  }
  cout << endl;

  std::cout << endl;
  std::cout << "== GPU output begins ==" << endl << endl;
  device->FlushPrintBuffer();
  std::cout << endl << "==  GPU output ends  ==" << endl;
  std::cout << " GPU Prefix Time = " << end - start << " msec " << endl;

  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
  // were created using this device instance that have not explicitly been
  // destroyed by calling the respective destroy functions.
  for (int i = 0; i < iterations; i++)
    cm_result_check(device->DestroyTask(mid_levels_tasks[i]));
  cm_result_check(::DestroyCmDevice(device));
  CM_ALIGNED_FREE(k2treeMatrix);
  CM_ALIGNED_FREE(Tsizes);
  for (int i = 0; i <= iterations; i++)
    CM_ALIGNED_FREE(Touts[i]);
  CM_ALIGNED_FREE(Touts);
  CM_ALIGNED_FREE(T);
  CM_ALIGNED_FREE(L);
  CM_ALIGNED_FREE(TBuf);
  CM_ALIGNED_FREE(T_idx);
  CM_ALIGNED_FREE(mid_levels_kernel);
  CM_ALIGNED_FREE(mid_levels_tasks);
}


void K2treeQueries(unsigned k, unsigned size, unsigned numThreads,
  string T_filename, string L_filename, string T_rank_filename, unsigned height, unsigned t_size, unsigned l_size) {

  std::vector<uint32_t> T, L, T_rank;
  if (!loadFromFile(T, T_filename)) {
    std::cout << "File " << T_filename << " couldn't be read.\n";
    exit(1);
  }
  if (!loadFromFile(L, L_filename)) {
    std::cout << "File " << L_filename << " couldn't be read.\n";
    exit(1);
  }
  if (!loadFromFile(T_rank, T_rank_filename)) {
    std::cout << "File " << T_rank_filename << " couldn't be read.\n";
    exit(1);
  }



  // Creates a CmDevice from scratch.
  // Param device: pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *device = nullptr;
  unsigned int version = 0;
  cm_result_check(::CreateCmDevice(device, version));
  // The file linear_walker_genx.isa is generated when the kernels in the file
  // linear_walker_genx.cpp are compiled by the CM compiler.
  // Reads in the virtual ISA from "K2tree_genx.isa" to the code
  // buffer.
  std::string isa_code = cm::util::isa::loadFile("IndexBuilder_genx.isa");
  if (isa_code.size() == 0) {
    std::cout << "Error: empty ISA binary.\n";
    exit(1);
  }

  // Creates a CmProgram object consisting of the kernels loaded from the code
  // buffer.
  // Param isa_code.data(): Pointer to the code buffer containing the virtual
  // ISA.
  // Param isa_code.size(): Size in bytes of the code buffer containing the
  // virtual ISA.
  CmProgram *program = nullptr;
  cm_result_check(device->LoadProgram(const_cast<char*>(isa_code.data()),
    isa_code.size(),
    program));

  CmKernel *neighbors_kernel = nullptr;
  cm_result_check(device->CreateKernel(program,
    CM_KERNEL_FUNCTION(cmk_neighbors_test),
    neighbors_kernel));
  CmKernel *range_kernel = nullptr;
  cm_result_check(device->CreateKernel(program,
    CM_KERNEL_FUNCTION(cmk_range_test),
    range_kernel));

  // create buffers for input matrix, T and L
  CmBuffer *TBuf;
  cm_result_check(device->CreateBuffer(T.size() * sizeof(unsigned int), TBuf));
  cm_result_check(TBuf->WriteSurface((const unsigned char*)T.data(), NULL));
  CmBuffer *LBuf;
  cm_result_check(device->CreateBuffer(L.size() * sizeof(unsigned int), LBuf));
  cm_result_check(LBuf->WriteSurface((const unsigned char*)L.data(), NULL));
  CmBuffer *T_rankBuf;
  cm_result_check(device->CreateBuffer(T_rank.size() * sizeof(unsigned int), T_rankBuf));
  cm_result_check(T_rankBuf->WriteSurface((const unsigned char*)T_rank.data(), NULL));

  // When a surface is created by the CmDevice a SurfaceIndex object is
  // created. This object contains a unique index value that is mapped to the
  // surface.
  // Gets the input surface index.
  SurfaceIndex *T_idx = nullptr;
  cm_result_check(TBuf->GetIndex(T_idx));
  SurfaceIndex *L_idx = nullptr;
  cm_result_check(LBuf->GetIndex(L_idx));
  SurfaceIndex *T_rank_idx = nullptr;
  cm_result_check(T_rankBuf->GetIndex(T_rank_idx));

  //SurfaceIndex *output_idx = nullptr;
  //cm_result_check(outBuf->GetIndex(output_idx));

  // Creates a CmThreadSpace object.
  // There are two usage models for the thread space. One is to define the
  // dependency between threads to run in the GPU. The other is to define a
  // thread space where each thread can get a pair of coordinates during
  // kernel execution. For this example, we use the latter usage model.
  //CmThreadSpace *thread_space = nullptr;
  //cm_result_check(device->CreateThreadSpace(width, height, thread_space));

  // Creates a task queue.
  // The CmQueue is an in-order queue. Tasks get executed according to the
  // order they are enqueued. The next task does not start execution until the
  // current task finishes.
  device->InitPrintBuffer();
  CmQueue *cmd_queue = nullptr;
  cm_result_check(device->CreateQueue(cmd_queue));

  // for range queries and their thread space
  unsigned width = sqrt(numThreads);
  unsigned height_ = sqrt(numThreads);
  unsigned block = size / width;
  CmThreadSpace *thread_space = nullptr;
  cm_result_check(device->CreateThreadSpace(width, height_, thread_space));

  cm_result_check(neighbors_kernel->SetThreadCount(numThreads));
  //cm_result_check(range_kernel->SetThreadCount(numThreads));
  cm_result_check(neighbors_kernel->SetKernelArg(0, sizeof(SurfaceIndex), T_idx));
  cm_result_check(range_kernel->SetKernelArg(0, sizeof(SurfaceIndex), T_idx));
  cm_result_check(neighbors_kernel->SetKernelArg(1, sizeof(SurfaceIndex), L_idx));
  cm_result_check(range_kernel->SetKernelArg(1, sizeof(SurfaceIndex), L_idx));
  cm_result_check(neighbors_kernel->SetKernelArg(2, sizeof(SurfaceIndex), T_rank_idx));
  cm_result_check(range_kernel->SetKernelArg(2, sizeof(SurfaceIndex), T_rank_idx));
  cm_result_check(neighbors_kernel->SetKernelArg(3, sizeof(uint32_t), &t_size));
  cm_result_check(range_kernel->SetKernelArg(3, sizeof(uint32_t), &t_size));
  cm_result_check(neighbors_kernel->SetKernelArg(4, sizeof(uint32_t), &l_size));
  cm_result_check(range_kernel->SetKernelArg(4, sizeof(uint32_t), &l_size));
  cm_result_check(neighbors_kernel->SetKernelArg(5, sizeof(uint32_t), &height));
  cm_result_check(range_kernel->SetKernelArg(5, sizeof(uint32_t), &height));
  cm_result_check(neighbors_kernel->SetKernelArg(6, sizeof(uint32_t), &k));
  cm_result_check(range_kernel->SetKernelArg(6, sizeof(uint32_t), &k));


  unsigned chunk = (size) / numThreads;
  for (unsigned i = 0; i < numThreads; i++) {
    unsigned start = chunk * i;
    unsigned end = chunk * i + chunk;
    cm_result_check(neighbors_kernel->SetThreadArg(i, 7, sizeof(start), &start));

    cm_result_check(neighbors_kernel->SetThreadArg(i, 8, sizeof(end), &end));

  }
  cm_result_check(range_kernel->SetKernelArg(7, sizeof(block), &block));
  cm_result_check(range_kernel->SetKernelArg(8, sizeof(block), &block));
  // Creates a CmTask object.
  // The CmTask object is a container for CmKernel pointers. It is used to
  // enqueue the kernels for execution.
  CmTask *neighbors_task = nullptr;
  cm_result_check(device->CreateTask(neighbors_task));
  CmTask *range_task = nullptr;
  cm_result_check(device->CreateTask(range_task));
  // Adds a CmKernel pointer to CmTask.
  cm_result_check(neighbors_task->AddKernel(neighbors_kernel));
  cm_result_check(range_task->AddKernel(range_kernel));


  std::cout << "K2tree neighbors test Start..." << endl;

  clock_t start = clock(); // start timer


                           // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
                           // function returns immediately without waiting for the GPU to start or
                           // finish execution of the task. The runtime will query the HW status. If
                           // the hardware is not busy, the runtime will submit the task to the
                           // driver/HW; otherwise, the runtime will submit the task to the driver/HW
                           // at another time.
                           // An event, "sync_event", is created to track the status of the task.
  CmEvent *event = nullptr;
  unsigned long time_out = -1;

  // For small input size, we only have a small number of threads
  // we don't call kernel to compute prefix sum. intead of, CPU simply performs the job
  cm_result_check(cmd_queue->Enqueue(neighbors_task, event));
  cm_result_check(event->WaitForTaskFinished(time_out));

  clock_t end = clock(); // end timer

  std::cout << endl;
  std::cout << "== GPU output begins ==" << endl << endl;
  device->FlushPrintBuffer();
  std::cout << endl << "==  GPU output ends  ==" << endl;
  std::cout << " GPU Prefix Time = " << end - start << " msec " << endl;


  /****************************************************
  * Kernel for Range query
  ****************************************************/
  device->InitPrintBuffer();

  std::cout << "K2tree range test Start..." << endl;

  start = clock(); // start timer


                           // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
                           // function returns immediately without waiting for the GPU to start or
                           // finish execution of the task. The runtime will query the HW status. If
                           // the hardware is not busy, the runtime will submit the task to the
                           // driver/HW; otherwise, the runtime will submit the task to the driver/HW
                           // at another time.
                           // An event, "sync_event", is created to track the status of the task.

  // For small input size, we only have a small number of threads
  // we don't call kernel to compute prefix sum. intead of, CPU simply performs the job
  cm_result_check(cmd_queue->Enqueue(range_task, event, thread_space));
  cm_result_check(event->WaitForTaskFinished(time_out));

  end = clock(); // end timer

  std::cout << endl;
  std::cout << "== GPU output begins ==" << endl << endl;
  device->FlushPrintBuffer();
  std::cout << endl << "==  GPU output ends  ==" << endl;
  std::cout << " GPU Range Time = " << end - start << " msec " << endl;

  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
  // were created using this device instance that have not explicitly been
  // destroyed by calling the respective destroy functions.
  cm_result_check(device->DestroyTask(neighbors_task));
  cm_result_check(device->DestroyTask(range_task));
  cm_result_check(::DestroyCmDevice(device));
}



void K2treeConstructionFromEdges(unsigned int size, uint64_t *edges) {

  /*
  uint64_t *edges;
  edges = (uint64_t*)CM_ALIGNED_MALLOC((size) * sizeof(uint64_t), 0x1000);
  memset(edges, 0, sizeof(uint64_t) * (size));
  //set values
  edges[0] = 6; // 1;
  edges[1] = 7; // 18;
  edges[2] = 10; // 19;
  edges[3] = 11; // 20;
  edges[4] = 18; // 22;
  edges[5] = 30; // 23;
  edges[6] = 55; // 25;
  edges[7] = 62; // 41;
  edges[8] = 73; // 42;
  edges[9] = 98; // 48;
  edges[10] = 104; // 52;
  edges[11] = 146; // 53;
  edges[12] = 148; // 54;
  edges[13] = 150; // 0;

  edges[256] = 6; // 1;
  edges[257] = 7; // 18;
  edges[258] = 10; // 19;
  edges[259] = 11; // 20;
  edges[260] = 18; // 22;
  edges[261] = 30; // 23;
  edges[262] = 55; // 25;
  edges[263] = 62; // 41;
  edges[264] = 73; // 42;
  edges[265] = 98; // 48;
  edges[266] = 104; // 52;
  edges[267] = 146; // 53;
  edges[268] = 148; // 54;
  edges[269] = 150; // 0;
  */


  // Allocate space for final K2tree structures L and T
  uint64_t *L;
  uint32_t l_size = size / 64;
  L = (uint64_t*)CM_ALIGNED_MALLOC((l_size) * sizeof(uint64_t), 0x1000);
  memset(L, 0, sizeof(uint64_t) * (l_size));
  uint64_t *T;
  T = (uint64_t*)CM_ALIGNED_MALLOC((size / 64) * sizeof(uint64_t), 0x1000);
  memset(T, 0, sizeof(uint64_t) * (size / 64));
  // determine how many threads we need for each iteration
  unsigned int width, height; // thread space width and height
  unsigned int total_threads = size / K_EDGES;
  if (total_threads > MAX_TS_WIDTH) {
	  width = MAX_TS_WIDTH;
	  height = total_threads / MAX_TS_WIDTH;
  }
  else {
	  width = total_threads;
	  height = 1;
  }
  


  // Creates a CmDevice from scratch.
  // Param device: pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *device = nullptr;
  unsigned int version = 0;
  cm_result_check(::CreateCmDevice(device, version));
  // The file linear_walker_genx.isa is generated when the kernels in the file
  // linear_walker_genx.cpp are compiled by the CM compiler.
  // Reads in the virtual ISA from "K2tree_genx.isa" to the code
  // buffer.
  std::string isa_code = cm::util::isa::loadFile("IndexBuilder_genx.isa");
  if (isa_code.size() == 0) {
    std::cout << "Error: empty ISA binary.\n";
    exit(1);
  }

  // Creates a CmProgram object consisting of the kernels loaded from the code
  // buffer.
  // Param isa_code.data(): Pointer to the code buffer containing the virtual
  // ISA.
  // Param isa_code.size(): Size in bytes of the code buffer containing the
  // virtual ISA.
  CmProgram *program = nullptr;
  cm_result_check(device->LoadProgram(const_cast<char*>(isa_code.data()),
    isa_code.size(),
    program));

  // Last_levels kernel will generate L and last 3 levels of T
  CmKernel *construction_edges_kernel = nullptr;
  cm_result_check(device->CreateKernel(program,
    CM_KERNEL_FUNCTION(cmk_construction_from_edges),
    construction_edges_kernel));

  std::cout << "# threads Kernel: " << total_threads << endl;

  // create buffers for input matrix, T and L
  CmBuffer *edgesBuf;
  cm_result_check(device->CreateBuffer(size * sizeof(uint64_t), edgesBuf));
  cm_result_check(edgesBuf->WriteSurface((const unsigned char*)edges, NULL));
  CmBuffer *outBuf;
  cm_result_check(device->CreateBuffer(l_size * sizeof(uint64_t), outBuf));


  // When a surface is created by the CmDevice a SurfaceIndex object is
  // created. This object contains a unique index value that is mapped to the
  // surface.
  // Gets the input surface index.
  SurfaceIndex *edges_idx = nullptr;
  cm_result_check(edgesBuf->GetIndex(edges_idx));
  SurfaceIndex *out_idx = nullptr;
  cm_result_check(outBuf->GetIndex(out_idx));

  // Creates a CmThreadSpace object.
  // There are two usage models for the thread space. One is to define the
  // dependency between threads to run in the GPU. The other is to define a
  // thread space where each thread can get a pair of coordinates during
  // kernel execution. For this example, we use the latter usage model.
  CmThreadSpace *thread_space = nullptr;
  cm_result_check(device->CreateThreadSpace(width, height, thread_space));

  // Creates a task queue.
  // The CmQueue is an in-order queue. Tasks get executed according to the
  // order they are enqueued. The next task does not start execution until the
  // current task finishes.
  device->InitPrintBuffer();
  CmQueue *cmd_queue = nullptr;
  cm_result_check(device->CreateQueue(cmd_queue));


  
  cm_result_check(construction_edges_kernel->SetKernelArg(0, sizeof(SurfaceIndex), edges_idx));
  cm_result_check(construction_edges_kernel->SetKernelArg(1, sizeof(SurfaceIndex), out_idx));
  cm_result_check(construction_edges_kernel->SetKernelArg(2, sizeof(size), &size));

  static const uint PRECOMPUTED_SUM[256] = { 0, 0, 0, 16, 0, 256, 256, 528, 0, 4096, 4096, 8208, 4096, 8448, 8448, 12816, 0, 65536, 65536, 131088,
	  65536, 131328, 131328, 197136, 65536, 135168, 135168, 204816, 135168, 205056, 205056, 274960, 0, 1048576, 1048576, 2097168, 1048576, 2097408,
	  2097408, 3146256, 1048576, 2101248, 2101248, 3153936, 2101248, 3154176, 3154176, 4207120, 1048576, 2162688, 2162688, 3276816, 2162688, 3277056,
	  3277056, 4391440, 2162688, 3280896, 3280896, 4399120, 3280896, 4399360, 4399360, 5517840, 0, 16777216, 16777216, 33554448, 16777216, 33554688,
	  33554688, 50332176, 16777216, 33558528, 33558528, 50339856, 33558528, 50340096, 50340096, 67121680, 16777216, 33619968, 33619968, 50462736, 33619968,
	  50462976, 50462976, 67306000, 33619968, 50466816, 50466816, 67313680, 50466816, 67313920, 67313920, 84161040, 16777216, 34603008, 34603008, 52428816,
	  34603008, 52429056, 52429056, 70255120, 34603008, 52432896, 52432896, 70262800, 52432896, 70263040, 70263040, 88093200, 34603008, 52494336, 52494336,
	  70385680, 52494336, 70385920, 70385920, 88277520, 52494336, 70389760, 70389760, 88285200, 70389760, 88285440, 88285440, 106181136, 0, 268435456,
	  268435456, 536870928, 268435456, 536871168, 536871168, 805306896, 268435456, 536875008, 536875008, 805314576, 536875008, 805314816, 805314816,
	  1073754640, 268435456, 536936448, 536936448, 805437456, 536936448, 805437696, 805437696, 1073938960, 536936448, 805441536, 805441536, 1073946640,
	  805441536, 1073946880, 1073946880, 1342452240, 268435456, 537919488, 537919488, 807403536, 537919488, 807403776, 807403776, 1076888080, 537919488,
	  807407616, 807407616, 1076895760, 807407616, 1076896000, 1076896000, 1346384400, 537919488, 807469056, 807469056, 1077018640, 807469056, 1077018880,
	  1077018880, 1346568720, 807469056, 1077022720, 1077022720, 1346576400, 1077022720, 1346576640, 1346576640, 1616130576, 268435456, 553648128, 553648128,
	  838860816, 553648128, 838861056, 838861056, 1124074000, 553648128, 838864896, 838864896, 1124081680, 838864896, 1124081920, 1124081920, 1409298960,
	  553648128, 838926336, 838926336, 1124204560, 838926336, 1124204800, 1124204800, 1409483280, 838926336, 1124208640, 1124208640, 1409490960, 1124208640,
	  1409491200, 1409491200, 1694773776, 553648128, 839909376, 839909376, 1126170640, 839909376, 1126170880, 1126170880, 1412432400, 839909376, 1126174720,
	  1126174720, 1412440080, 1126174720, 1412440320, 1412440320, 1698705936, 839909376, 1126236160, 1126236160, 1412562960, 1126236160, 1412563200, 1412563200,
	  1698890256, 1126236160, 1412567040, 1412567040, 1698897936, 1412567040, 1698898176, 1698898176, 1985229328 };

  cm_result_check(construction_edges_kernel->SetKernelArg(3, sizeof(uint32_t) * 256, PRECOMPUTED_SUM));



  // Creates a CmTask object.
  // The CmTask object is a container for CmKernel pointers. It is used to
  // enqueue the kernels for execution.
  CmTask *construction_edges_task = nullptr;
  cm_result_check(device->CreateTask(construction_edges_task));

  // Adds a CmKernel pointer to CmTask.
  cm_result_check(construction_edges_task->AddKernel(construction_edges_kernel));

  std::cout << "K2tree Construction test Start..." << endl;

  clock_t start = clock(); // start timer


                           // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
                           // function returns immediately without waiting for the GPU to start or
                           // finish execution of the task. The runtime will query the HW status. If
                           // the hardware is not busy, the runtime will submit the task to the
                           // driver/HW; otherwise, the runtime will submit the task to the driver/HW
                           // at another time.
                           // An event, "sync_event", is created to track the status of the task.
  CmEvent *event = nullptr;
  unsigned long time_out = -1;

  // For small input size, we only have a small number of threads
  // we don't call kernel to compute prefix sum. intead of, CPU simply performs the job
  cm_result_check(cmd_queue->Enqueue(construction_edges_task, event, thread_space));
  cm_result_check(event->WaitForTaskFinished(time_out));

  clock_t end = clock(); // end timer

  cm_result_check(outBuf->ReadSurface((unsigned char *)L, event));
  std::cout << "Result:\n";
  for (int i = 0; i < 8; i++) {
	  std::cout << L[i] << " ";
  }
  std::cout << std::endl;
  for (int i = 8; i < 16; i++) {
	  std::cout << L[i] << " ";
  }
  std::cout << std::endl;


  std::cout << endl;
  std::cout << "== GPU output begins ==" << endl << endl;
  device->FlushPrintBuffer();
  std::cout << endl << "==  GPU output ends  ==" << endl;
  std::cout << " GPU Prefix Time = " << end - start << " msec " << endl;

  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
  // were created using this device instance that have not explicitly been
  // destroyed by calling the respective destroy functions.

  CM_ALIGNED_FREE(T);
  CM_ALIGNED_FREE(L);
}

void generateMortonNumbers(uint32_t size, std::vector<uint32_t> &vertices_x, std::vector<uint32_t> &vertices_y, uint64_t *mortonNumbers) {

  unsigned int numEdges = size;
  unsigned int numMortonNumbers = size;

  uint32_t *edges_x;
  edges_x = (uint32_t*)CM_ALIGNED_MALLOC((numEdges) * sizeof(uint32_t), 0x1000);
  //memset(edges_x, 0, sizeof(uint32_t) * numEdges);

  uint32_t *edges_y;
  edges_y = (uint32_t*)CM_ALIGNED_MALLOC((numEdges) * sizeof(uint32_t), 0x1000);


  

  // determine how many threads we need for each iteration
  unsigned int width, height; // thread space width and height
  unsigned int total_threads = size / K_EDGES;
  if (total_threads > MAX_TS_WIDTH) {
	  width = MAX_TS_WIDTH;
	  height = total_threads / MAX_TS_WIDTH;
  }
  else {
	  width = total_threads;
	  height = 1;
  }



  // Creates a CmDevice from scratch.
  // Param device: pointer to the CmDevice object.
  // Param version: CM API version supported by the runtime library.
  CmDevice *device = nullptr;
  unsigned int version = 0;
  cm_result_check(::CreateCmDevice(device, version));
  // The file linear_walker_genx.isa is generated when the kernels in the file
  // linear_walker_genx.cpp are compiled by the CM compiler.
  // Reads in the virtual ISA from "K2tree_genx.isa" to the code
  // buffer.
  std::string isa_code = cm::util::isa::loadFile("IndexBuilder_genx.isa");
  if (isa_code.size() == 0) {
    std::cout << "Error: empty ISA binary.\n";
    exit(1);
  }

  // Creates a CmProgram object consisting of the kernels loaded from the code
  // buffer.
  // Param isa_code.data(): Pointer to the code buffer containing the virtual
  // ISA.
  // Param isa_code.size(): Size in bytes of the code buffer containing the
  // virtual ISA.
  CmProgram *program = nullptr;
  cm_result_check(device->LoadProgram(const_cast<char*>(isa_code.data()),
    isa_code.size(),
    program));

  // Last_levels kernel will generate L and last 3 levels of T
  CmKernel *morton_kernel = nullptr;
  cm_result_check(device->CreateKernel(program,
    CM_KERNEL_FUNCTION(cmk_generate_morton_numbers),
    morton_kernel));

  std::cout << "# threads Kernel: " << total_threads << endl;

  // create buffers for input/output
  CmBuffer *edgesXBuf;
  cm_result_check(device->CreateBuffer(numEdges * sizeof(uint32_t), edgesXBuf));
  cm_result_check(edgesXBuf->WriteSurface((const unsigned char*)vertices_x.data(), NULL));
  CmBuffer *edgesYBuf;
  cm_result_check(device->CreateBuffer(numEdges * sizeof(uint32_t), edgesYBuf));
  cm_result_check(edgesYBuf->WriteSurface((const unsigned char*)vertices_y.data(), NULL));
  CmBuffer *mortonBuf;
  cm_result_check(device->CreateBuffer(numMortonNumbers * sizeof(uint64_t), mortonBuf));



  // When a surface is created by the CmDevice a SurfaceIndex object is
  // created. This object contains a unique index value that is mapped to the
  // surface.
  // Gets the input surface index.
  SurfaceIndex *edges_x_idx = nullptr;
  cm_result_check(edgesXBuf->GetIndex(edges_x_idx));
  SurfaceIndex *edges_y_idx = nullptr;
  cm_result_check(edgesYBuf->GetIndex(edges_y_idx));
  SurfaceIndex *morton_idx = nullptr;
  cm_result_check(mortonBuf->GetIndex(morton_idx));
  ;

  // Creates a CmThreadSpace object.
  // There are two usage models for the thread space. One is to define the
  // dependency between threads to run in the GPU. The other is to define a
  // thread space where each thread can get a pair of coordinates during
  // kernel execution. For this example, we use the latter usage model.
  CmThreadSpace *thread_space = nullptr;
  cm_result_check(device->CreateThreadSpace(width, height, thread_space));

  // Creates a task queue.
  // The CmQueue is an in-order queue. Tasks get executed according to the
  // order they are enqueued. The next task does not start execution until the
  // current task finishes.
  device->InitPrintBuffer();
  CmQueue *cmd_queue = nullptr;
  cm_result_check(device->CreateQueue(cmd_queue));


  //cm_result_check(morton_kernel->SetThreadCount(total_threads));
  cm_result_check(morton_kernel->SetKernelArg(0, sizeof(SurfaceIndex), edges_x_idx));
  cm_result_check(morton_kernel->SetKernelArg(1, sizeof(SurfaceIndex), edges_y_idx));
  cm_result_check(morton_kernel->SetKernelArg(2, sizeof(SurfaceIndex), morton_idx)); 
  cm_result_check(morton_kernel->SetKernelArg(3, sizeof(uint32_t), &numEdges));



  // Creates a CmTask object.
  // The CmTask object is a container for CmKernel pointers. It is used to
  // enqueue the kernels for execution.
  CmTask *construction_edges_task = nullptr;
  cm_result_check(device->CreateTask(construction_edges_task));

  // Adds a CmKernel pointer to CmTask.
  cm_result_check(construction_edges_task->AddKernel(morton_kernel));

  std::cout << "K2tree Construction test Start..." << endl;

  clock_t start = clock(); // start timer


                           // Launches the task on the GPU. Enqueue is a non-blocking call, i.e. the
                           // function returns immediately without waiting for the GPU to start or
                           // finish execution of the task. The runtime will query the HW status. If
                           // the hardware is not busy, the runtime will submit the task to the
                           // driver/HW; otherwise, the runtime will submit the task to the driver/HW
                           // at another time.
                           // An event, "sync_event", is created to track the status of the task.
  CmEvent *event = nullptr;
  unsigned long time_out = -1;

  // For small input size, we only have a small number of threads
  // we don't call kernel to compute prefix sum. intead of, CPU simply performs the job
  cm_result_check(cmd_queue->Enqueue(construction_edges_task, event, thread_space));
  cm_result_check(event->WaitForTaskFinished(time_out));

  clock_t end = clock(); // end timer

  cm_result_check(mortonBuf->ReadSurface((unsigned char *)mortonNumbers, event));

  std::cout << endl;
  std::cout << "== GPU output begins ==" << endl << endl;
  device->FlushPrintBuffer();
  std::cout << endl << "==  GPU output ends  ==" << endl;
  std::cout << " GPU Prefix Time = " << end - start << " msec " << endl;

  std::cout << "Morton number " << mortonNumbers[0] << std::endl;
  std::cout << "Morton number " << mortonNumbers[1] << std::endl;
  std::cout << "Morton number " << mortonNumbers[2] << std::endl;
  std::cout << "Morton number " << mortonNumbers[3] << std::endl;
  std::cout << "edge  (" << vertices_x[1000000] << ", " << vertices_y[1000000] << ") = " << mortonNumbers[1000000] << std::endl;
  // Destroys the CmDevice.
  // Also destroys surfaces, kernels, tasks, thread spaces, and queues that
  // were created using this device instance that have not explicitly been
  // destroyed by calling the respective destroy functions.

  CM_ALIGNED_FREE(edges_x);
  CM_ALIGNED_FREE(edges_y);
  

}


double getSeconds() {
	LARGE_INTEGER freq, val;
	QueryPerformanceFrequency(&freq);
	QueryPerformanceCounter(&val);
	return (double)val.QuadPart / (double)freq.QuadPart;
}

struct SortResults {
	std::string algorithm = "";
	size_t numKeys = 0;

	double totalGPUTimeMS = 0.0;
	double totalCPUTimeMS = 0.0;
	double throughputMKeys = 0.0;

	void print() {
		std::cout << "---- ALGORITHM: " << algorithm << " ----" << std::endl;
		std::cout << "Total time GPU clock:       " << totalGPUTimeMS << " ms" << std::endl;
		std::cout << "Total time CPU clock:       " << totalCPUTimeMS << " ms" << std::endl;
		std::cout << "Throughput:                 " << throughputMKeys << " MKeys/s" << std::endl;
		std::cout << std::endl;
	}
};

SortResults sortVectorCM(KeyType *&keys, uint32_t numKeys) {
	// Initialize CM Device
	CmDevice *device = nullptr;
	unsigned int version = 0;
	cm_result_check(::CreateCmDevice(device, version));

	// Initialize CmProgram
	std::string isa_code = cm::util::isa::loadFile("IndexBuilder_genx.isa");
	if (isa_code.size() == 0) {
		std::cout << "Error: empty ISA binary" << std::endl;
		exit(1);
	}

	CmProgram *program = nullptr;
	cm_result_check(device->LoadProgram(const_cast<char*>(isa_code.data()), isa_code.size(), program));

	// Initialize Cm Kernels
	CmKernel *HistKernel = nullptr;
	cm_result_check(device->CreateKernel(program, CM_KERNEL_FUNCTION(PerThreadHist), HistKernel));

	CmKernel *HistScanKernel = nullptr;
	cm_result_check(device->CreateKernel(program, CM_KERNEL_FUNCTION(ScanHist), HistScanKernel));

	CmKernel *KeyScanKernel = nullptr;
#ifdef SLM_COALESCE
	cm_result_check(device->CreateKernel(program, CM_KERNEL_FUNCTION(ScanKeys), KeyScanKernel));
#else
	cm_result_check(device->CreateKernel(program, CM_KERNEL_FUNCTION(ScanKeysUncoalesced), KeyScanKernel));
#endif

	// Initialize Cm Threadspaces
#ifdef CMRT_EMU
	CmThreadSpace *tsHist = nullptr;
	CmThreadSpace *tsHistScan = nullptr;

	cm_result_check(device->CreateThreadSpace(GPU_THREADS, 1, tsHist));
	cm_result_check(device->CreateThreadSpace(1, 1, tsHistScan));
#else
	CmThreadGroupSpace *tsHist = nullptr;
	CmThreadGroupSpace *tsHistScan = nullptr;

	cm_result_check(device->CreateThreadGroupSpace(WG_SIZE, 1, GPU_THREADS / WG_SIZE, 1, tsHist));
	cm_result_check(device->CreateThreadGroupSpace(1, 1, 1, 1, tsHistScan));
#endif

	// Initialize Sort Buffers
	CmBufferSVM *histBuff = nullptr;
	CmBufferSVM *histScanBuff = nullptr;
	CmBufferSVM *inputBuff = nullptr;
	CmBufferSVM *outputBuff = nullptr;

	// declare pointers to hold buffer data
	void *inputBuffData = keys;
	void *outputBuffData = nullptr;
	void *histBuffData = nullptr;
	void *histScanBuffData = nullptr;

	// create buffers on device
	cm_result_check(device->CreateBufferSVM(numKeys * sizeof(KeyType), inputBuffData, CM_SVM_ACCESS_FLAG_DEFAULT, inputBuff));
	cm_result_check(device->CreateBufferSVM(numKeys * sizeof(KeyType), outputBuffData, CM_SVM_ACCESS_FLAG_DEFAULT, outputBuff));

	cm_result_check(device->CreateBufferSVM((GPU_THREADS * RADIX_SIZE) * sizeof(uint32_t), histBuffData, CM_SVM_ACCESS_FLAG_DEFAULT, histBuff));
	cm_result_check(device->CreateBufferSVM(((GPU_THREADS + 1) * RADIX_SIZE) * sizeof(uint32_t), histScanBuffData, CM_SVM_ACCESS_FLAG_DEFAULT, histScanBuff));

	// Initialize Cm Tasks
	CmTask *HistTask = nullptr;
	cm_result_check(device->CreateTask(HistTask));
	cm_result_check(HistTask->AddKernel(HistKernel));

	CmTask *HistScanTask = nullptr;
	cm_result_check(device->CreateTask(HistScanTask));
	cm_result_check(HistScanTask->AddKernel(HistScanKernel));

	CmTask *KeyScanTask = nullptr;
	cm_result_check(device->CreateTask(KeyScanTask));
	cm_result_check(KeyScanTask->AddKernel(KeyScanKernel));

	// Initialize Task Queue
	CmQueue *taskQueue = nullptr;
	cm_result_check(device->CreateQueue(taskQueue));

	// Intialize events
	CmEvent *HistTaskEvent = nullptr;
	CmEvent *HistScanTaskEvent = nullptr;
	CmEvent *KeyScanTaskEvent = nullptr;

	// Performance timing variables
	uint64_t histKernelTime = 0;
	uint64_t histScanKernelTime = 0;
	uint64_t keyScanKernelTime = 0;
	uint64_t totalGPUTime = 0;
	double cpuTimeStart = getSeconds();

	// start sorting
	clock_t start = clock(); // end timer
	for (uint32_t radixPos = 0; radixPos < KEY_DIGITS; radixPos += RADIX_DIGITS) {
		// set kernel parameters
		cm_result_check(HistKernel->SetKernelArg(0, sizeof(numKeys), &numKeys));
		cm_result_check(HistKernel->SetKernelArg(1, sizeof(radixPos), &radixPos));
		cm_result_check(HistKernel->SetKernelArg(2, sizeof(void *), &inputBuffData));
		cm_result_check(HistKernel->SetKernelArg(3, sizeof(void *), &histBuffData));

		cm_result_check(HistScanKernel->SetKernelArg(0, sizeof(void *), &histBuffData));
		cm_result_check(HistScanKernel->SetKernelArg(1, sizeof(void *), &histScanBuffData));

		cm_result_check(KeyScanKernel->SetKernelArg(0, sizeof(numKeys), &numKeys));
		cm_result_check(KeyScanKernel->SetKernelArg(1, sizeof(radixPos), &radixPos));
		cm_result_check(KeyScanKernel->SetKernelArg(2, sizeof(void *), &inputBuffData));
		cm_result_check(KeyScanKernel->SetKernelArg(3, sizeof(void *), &histScanBuffData));
		cm_result_check(KeyScanKernel->SetKernelArg(4, sizeof(void *), &outputBuffData));

		// Enqueue Tasks
		// Note that for EMU Mode we use a standard threadspace but with HW mode we use a threadgroupspace
		
#ifdef CMRT_EMU
		cm_result_check(taskQueue->Enqueue(HistTask, HistTaskEvent, tsHist));
		cm_result_check(HistTaskEvent->WaitForTaskFinished());

		cm_result_check(taskQueue->Enqueue(HistScanTask, HistScanTaskEvent, tsHistScan));
		cm_result_check(HistScanTaskEvent->WaitForTaskFinished());

		cm_result_check(taskQueue->Enqueue(KeyScanTask, KeyScanTaskEvent, tsHist));
		cm_result_check(KeyScanTaskEvent->WaitForTaskFinished());
#else
		cm_result_check(taskQueue->EnqueueWithGroup(HistTask, HistTaskEvent, tsHist));
		cm_result_check(HistTaskEvent->WaitForTaskFinished());

		cm_result_check(taskQueue->EnqueueWithGroup(HistScanTask, HistScanTaskEvent, tsHistScan));
		cm_result_check(HistScanTaskEvent->WaitForTaskFinished());

		cm_result_check(taskQueue->EnqueueWithGroup(KeyScanTask, KeyScanTaskEvent, tsHist));
		cm_result_check(KeyScanTaskEvent->WaitForTaskFinished());
#endif
		// Get execution time
		cm_result_check(HistTaskEvent->GetExecutionTime(histKernelTime));
		cm_result_check(HistScanTaskEvent->GetExecutionTime(histScanKernelTime));
		cm_result_check(KeyScanTaskEvent->GetExecutionTime(keyScanKernelTime));

		totalGPUTime += histKernelTime + histScanKernelTime + keyScanKernelTime;

		// destroy events
		cm_result_check(taskQueue->DestroyEvent(HistTaskEvent));
		cm_result_check(taskQueue->DestroyEvent(HistScanTaskEvent));
		cm_result_check(taskQueue->DestroyEvent(KeyScanTaskEvent));

		// swap the buffers
		std::swap(outputBuffData, inputBuffData);
	}
	clock_t end = clock(); // end timer
	std::cout << " GPU Sorting Time = " << end - start << " msec " << endl;
	double cpuTimeEnd = getSeconds();

	// calculate performance statistics
	SortResults sr;
	sr.algorithm = "genradixsort";
	sr.numKeys = numKeys;
	sr.totalCPUTimeMS = (cpuTimeEnd - cpuTimeStart) * 1E3;
	sr.totalGPUTimeMS = totalGPUTime / 1E6;
	sr.throughputMKeys = (float(numKeys) / (cpuTimeEnd - cpuTimeStart)) / 1E6;

	return sr;
}

SortResults sortVectorSTD(std::vector<KeyType> &keys) {
	// sort using std::sort
	double tStart = getSeconds();
	std::sort(keys.begin(), keys.end());
	double tEnd = getSeconds();
	double cpuTime = float(tEnd - tStart);

	// calculate performance statistics
	SortResults sr;
	sr.algorithm = "std::sort";
	sr.numKeys = keys.size();
	sr.totalCPUTimeMS = cpuTime * 1E3;
	sr.totalGPUTimeMS = -1.0;
	sr.throughputMKeys = (float(keys.size()) / cpuTime) / 1E6;

	return sr;
}

int radixSort(int numKeys, KeyType *inputPtr) {
	//uint32_t numKeys = 1024 * 1024;
	std::vector<KeyType> inputVector;
	//KeyType* inputPtr = (KeyType*)_aligned_malloc(numKeys * sizeof(KeyType), 4096);

	// generate random data
	//std::random_device r;
	//std::default_random_engine e1(0);
	//std::uniform_int_distribution<KeyType> uniform_dist(0, KeyType(std::numeric_limits<KeyType>::max));

	for (uint32_t i = 0; i < numKeys; i += 1) {
		//KeyType v = uniform_dist(e1);
		inputVector.push_back(inputPtr[i]);
		//inputPtr[i] = v;
	}

	// Sort using CM Radix Sort
	SortResults cmSR = sortVectorCM(inputPtr, numKeys);

	// Sort using std::sort
	SortResults stdSR = sortVectorSTD(inputVector);

	// validate sorting results
	bool isValid = true;
	for (size_t i = 0; i < numKeys; i++) {
		if (inputPtr[i] != inputVector[i]) {
			isValid = false;
			break;
		}
	}

	if (isValid) {
		std::cout << "Sort Is Valid" << std::endl;
		std::cout << std::endl;

		cmSR.print();
		stdSR.print();
	}
	else {
		std::cout << "Sort Is Not Valid" << std::endl;
		return 1;
	}

	return 0;
}

// load edges (x,y) from ARC file
bool loadEdges(std::string filename, std::vector<uint32_t> &vertices_x, std::vector<uint32_t> &vertices_y) {

		ifstream file(filename);
		if (!file.good())
			return false;
		uint32_t x, y, edges = 0;
		std::string line;
		while (std::getline(file, line)) {
			if (line[0] == '#') // # character
				continue;
			edges++;
		}
		file.clear();
		file.seekg(0, std::ios::beg);

		vertices_x.resize(edges);
		vertices_y.resize(edges);

		// Read edges
		uint32_t i = 0;
		while (std::getline(file, line)){
			if (line[0] == '#') // # character
				continue;
			std::istringstream ss(line);
			if (!(ss >> x >> y))
				return false;
			vertices_x[i] = x;
			vertices_y[i++] = y;
		}
		file.close();
		return true;

}


int main(int argc, char * argv[])
{

  // This program dispatches several kernels for K2tree utilization:
  //   1. Bits test kernel: Tests bit vector operations on Gen.
  //bitsTest();
  //   2. K2tree construction from matrix: Test the constrution of a K2tree
  //      from a binary matrix. Results are compared vs CPU version
  unsigned k = 2;
  unsigned numThreads = 1;
  unsigned size = 16;
  unsigned p = 3;
  unsigned height = 4;
  //unsigned t_size = 2784; unsigned l_size = 1912; // 128
  //unsigned t_size = 208112; unsigned l_size = 157864; // 1024
  unsigned t_size = 11477624; unsigned l_size = 7709184; // 8192

  

  std::string edgesFilename("web-BerkStan.txt");
  std::vector<uint32_t> vertices_x, vertices_y;

  if (!loadEdges(edgesFilename, vertices_x, vertices_y))
	  std::cout << "Error loading edges from ARC file\n";

  vertices_x.erase(vertices_x.begin() + (1024*1024*4), vertices_x.end()); //intentionally shrinked
  vertices_y.erase(vertices_y.begin() + (1024 * 1024*4), vertices_y.end());

  std::cout << "Loaded " << vertices_x.size() << " " << vertices_y.size() << " vertices from ARC file\n";

  int totalEdges = vertices_x.size();


  //K2treeConstructionTest(size*size, "matrix"+to_string(size)+"x"+to_string(size)+"_"+to_string(p)+".txt");
  //K2treeConstructionTest(size*size, "matrix16x16_original.txt");
  //K2treeConstructionTest(size*size, "matrix"+to_string(size)+"x"+to_string(size)+"_"+to_string(p)+".txt");
  //K2treeConstructionTest(size*size, "matrix"+to_string(size)+"x"+to_string(size)+"_"+to_string(p)+".txt");
  //K2treeQueries(k, size, numThreads, "T_"+to_string(size)+"_"+to_string(p)+"_h_"+to_string(height)+".txt",
  //  "L_"+to_string(size)+"_"+to_string(p)+".txt", "T_rank_"+to_string(size)+"_"+to_string(p)+".txt", height, t_size, l_size);
  
  // Allocate space for output
  uint64_t *mortonNumbers;
  mortonNumbers = (uint64_t*)CM_ALIGNED_MALLOC((totalEdges) * sizeof(uint64_t), 0x1000);
  memset(mortonNumbers, 0, sizeof(uint64_t) * (totalEdges));

  generateMortonNumbers(totalEdges, vertices_x, vertices_y, mortonNumbers);
  
  for (int i = 0; i < 20; i++) {
	  std::cout << mortonNumbers[i] << " ";
  }
  std::cout << std::endl;
  radixSort(totalEdges, mortonNumbers);


  K2treeConstructionFromEdges(totalEdges, mortonNumbers);

  for (int i = 0; i < 20; i++) {
	  std::cout << mortonNumbers[i] << " ";
  }
  std::cout << std::endl;


  CM_ALIGNED_FREE(mortonNumbers);
}
